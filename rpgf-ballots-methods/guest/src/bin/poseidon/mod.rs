use ff::Field;
use ff::PrimeField;
use halo2curves::bn256::Fr as Fp;
use std::convert::TryInto;
use std::fmt;
use std::iter;
use std::marker::PhantomData;

// Fork of the Poseidon hash function from EZKL's fork of the Halo2 library,
// (https://github.com/zkonduit/halo2/blob/main/halo2_gadgets/src/poseidon/primitives.rs)
// optimized for the R0 zkVM

mod poseidon_params;

/// The type used to hold permutation state.
pub(crate) type State<F, const T: usize> = [F; T];

/// The type used to hold sponge rate.
pub(crate) type SpongeRate<F, const RATE: usize> = [Option<F>; RATE];

// Alies for the string type that will contain the hex string ballot id

#[inline]
pub fn i128_to_felt<F: PrimeField>(x: i128) -> F {
    if x >= 0 {
        F::from_u128(x as u128)
    } else {
        -F::from_u128((-x) as u128)
    }
}

/// The specification for the Poseidon hash function.
#[derive(Debug, Clone, Copy)]
pub struct PoseidonSpec;

/// Basically the number of columns allocated within the poseidon chip
pub const POSEIDON_WIDTH: usize = 2;
/// The number of full SBox rounds
pub const POSEIDON_RATE: usize = 1;

pub(crate) type Mds<Fp, const T: usize> = [[Fp; T]; T];

impl Spec<Fp, POSEIDON_WIDTH, POSEIDON_RATE> for PoseidonSpec {
    fn full_rounds() -> usize {
        8
    }

    fn partial_rounds() -> usize {
        56
    }

    fn sbox(val: Fp) -> Fp {
        let square = val.square(); // x^2
        square.square().mul(&val) // (x^2)^2 * x = x^5
    }

    fn secure_mds() -> usize {
        unimplemented!()
    }

    fn constants() -> (
        Vec<[Fp; POSEIDON_WIDTH]>,
        Mds<Fp, POSEIDON_WIDTH>,
        Mds<Fp, POSEIDON_WIDTH>,
    ) {
        (
            poseidon_params::ROUND_CONSTANTS[..].to_vec(),
            poseidon_params::MDS,
            poseidon_params::MDS_INV,
        )
    }
}

/// A specification for a Poseidon permutation.
pub trait Spec<F: Field, const T: usize, const RATE: usize>: fmt::Debug {
    /// The number of full rounds for this specification.
    ///
    /// This must be an even number.
    fn full_rounds() -> usize;

    /// The number of partial rounds for this specification.
    fn partial_rounds() -> usize;

    /// The S-box for this specification.
    fn sbox(val: F) -> F;

    /// Side-loaded index of the first correct and secure MDS that will be generated by
    /// the reference implementation.
    ///
    /// This is used by the default implementation of [`Spec::constants`]. If you are
    /// hard-coding the constants, you may leave this unimplemented.
    fn secure_mds() -> usize;

    /// Generates `(round_constants, mds, mds^-1)` corresponding to this specification.
    fn constants() -> (Vec<[F; T]>, Mds<F, T>, Mds<F, T>);
}

/// Runs the Poseidon permutation on the given state.
#[inline]
pub(crate) fn permute<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>(
    state: &mut State<F, T>,
    mds: &Mds<F, T>,
    round_constants: &[[F; T]],
) {
    let r_f = S::full_rounds() / 2;
    let r_p = S::partial_rounds();

    // Mark as inline
    #[inline]
    fn apply_mds<F: Field, const T: usize>(state: &mut State<F, T>, mds: &Mds<F, T>) {
        let mut new_state = [F::ZERO; T];
        for i in 0..T {
            for j in 0..T {
                new_state[i] += mds[i][j] * state[j];
            }
        }
        *state = new_state;
    }

    for round in 0..(r_f + r_p + r_f) {
        let rcs = &round_constants[round];
        if round < r_f || round >= r_f + r_p {
            // Full round
            for (word, rc) in state.iter_mut().zip(rcs.iter()) {
                *word = S::sbox(*word + rc);
            }
        } else {
            // Partial round
            for (word, rc) in state.iter_mut().zip(rcs.iter()) {
                *word += rc;
            }
            state[0] = S::sbox(state[0]);
        }
        apply_mds(state, mds);
    }
}

#[inline]
fn poseidon_sponge<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>(
    state: &mut State<F, T>,
    input: Option<&Absorbing<F, RATE>>,
    mds_matrix: &Mds<F, T>,
    round_constants: &[[F; T]],
) -> Squeezing<F, RATE> {
    if let Some(Absorbing(input)) = input {
        // `Iterator::zip` short-circuits when one iterator completes, so this will only
        // mutate the rate portion of the state.
        for (word, value) in state.iter_mut().zip(input.iter()) {
            *word += value.expect("poseidon_sponge is called with a padded input");
        }
    }

    permute::<F, S, T, RATE>(state, mds_matrix, round_constants);

    let mut output = [None; RATE];
    for (word, value) in output.iter_mut().zip(state.iter()) {
        *word = Some(*value);
    }
    Squeezing(output)
}

mod private {
    pub trait SealedSpongeMode {}
    impl<F, const RATE: usize> SealedSpongeMode for super::Absorbing<F, RATE> {}
    impl<F, const RATE: usize> SealedSpongeMode for super::Squeezing<F, RATE> {}
}

/// The state of the `Sponge`.
pub trait SpongeMode: private::SealedSpongeMode {}

/// The absorbing state of the `Sponge`.
#[derive(Debug, Clone)]
pub struct Absorbing<F, const RATE: usize>(pub(crate) SpongeRate<F, RATE>);

/// The squeezing state of the `Sponge`.
#[derive(Debug)]
pub struct Squeezing<F, const RATE: usize>(pub(crate) SpongeRate<F, RATE>);

impl<F, const RATE: usize> SpongeMode for Absorbing<F, RATE> {}
impl<F, const RATE: usize> SpongeMode for Squeezing<F, RATE> {}

impl<F: fmt::Debug, const RATE: usize> Absorbing<F, RATE> {
    pub(crate) fn init_with(val: F) -> Self {
        Self(
            iter::once(Some(val))
                .chain((1..RATE).map(|_| None))
                .collect::<Vec<_>>()
                .try_into()
                .unwrap(),
        )
    }
}

#[derive(Clone)]
/// A Poseidon sponge.
pub(crate) struct Sponge<
    F: Field,
    S: Spec<F, T, RATE>,
    M: SpongeMode,
    const T: usize,
    const RATE: usize,
> {
    mode: M,
    state: State<F, T>,
    mds_matrix: Mds<F, T>,
    round_constants: Vec<[F; T]>,
    _marker: PhantomData<S>,
}

impl<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>
    Sponge<F, S, Absorbing<F, RATE>, T, RATE>
{
    /// Constructs a new sponge for the given Poseidon specification.
    pub(crate) fn new(initial_capacity_element: F) -> Self {
        let (round_constants, mds_matrix, _) = S::constants();

        let mode = Absorbing([None; RATE]);
        let mut state = [F::ZERO; T];
        state[RATE] = initial_capacity_element;

        Sponge {
            mode,
            state,
            mds_matrix,
            round_constants,
            _marker: PhantomData,
        }
    }

    /// Absorbs an element into the sponge.
    pub(crate) fn absorb(&mut self, value: F) {
        for entry in self.mode.0.iter_mut() {
            if entry.is_none() {
                *entry = Some(value);
                return;
            }
        }

        // We've already absorbed as many elements as we can
        let _ = poseidon_sponge::<F, S, T, RATE>(
            &mut self.state,
            Some(&self.mode),
            &self.mds_matrix,
            &self.round_constants,
        );
        self.mode = Absorbing::init_with(value);
    }

    /// Transitions the sponge into its squeezing state.
    pub(crate) fn finish_absorbing(mut self) -> Sponge<F, S, Squeezing<F, RATE>, T, RATE> {
        let mode = poseidon_sponge::<F, S, T, RATE>(
            &mut self.state,
            Some(&self.mode),
            &self.mds_matrix,
            &self.round_constants,
        );

        Sponge {
            mode,
            state: self.state,
            mds_matrix: self.mds_matrix,
            round_constants: self.round_constants,
            _marker: PhantomData,
        }
    }
}

impl<F: Field, S: Spec<F, T, RATE>, const T: usize, const RATE: usize>
    Sponge<F, S, Squeezing<F, RATE>, T, RATE>
{
    /// Squeezes an element from the sponge.
    pub(crate) fn squeeze(&mut self) -> F {
        loop {
            for entry in self.mode.0.iter_mut() {
                if let Some(e) = entry.take() {
                    return e;
                }
            }

            // We've already squeezed out all available elements
            self.mode = poseidon_sponge::<F, S, T, RATE>(
                &mut self.state,
                None,
                &self.mds_matrix,
                &self.round_constants,
            );
        }
    }
}

/// A domain in which a Poseidon hash function is being used.
pub trait Domain<F: Field, const RATE: usize> {
    /// Iterator that outputs padding field elements.
    type Padding: IntoIterator<Item = F>;

    /// The name of this domain, for debug formatting purposes.
    fn name() -> String;

    /// The initial capacity element, encoding this domain.
    fn initial_capacity_element() -> F;

    /// Returns the padding to be appended to the input.
    fn padding() -> Self::Padding;
}

/// A Poseidon hash function used with constant input length.
///
/// Domain specified in [ePrint 2019/458 section 4.2](https://eprint.iacr.org/2019/458.pdf).
#[derive(Clone, Copy, Debug)]
pub struct ConstantLength<const L: usize>;

impl<F: PrimeField, const RATE: usize, const L: usize> Domain<F, RATE> for ConstantLength<L> {
    type Padding = Vec<F>; // Change to Vec for dynamic sizing

    fn name() -> String {
        format!("ConstantLength<{}>", L)
    }

    fn initial_capacity_element() -> F {
        F::from_u128((L as u128) << 64)
    }

    fn padding() -> Self::Padding {
        let k = (L + RATE - 1) / RATE;
        vec![F::ZERO; k * RATE - L]
    }
}

#[derive(Clone)]
/// A Poseidon hash function, built around a sponge.
pub struct Hash<
    F: Field,
    S: Spec<F, T, RATE>,
    D: Domain<F, RATE>,
    const T: usize,
    const RATE: usize,
> {
    sponge: Sponge<F, S, Absorbing<F, RATE>, T, RATE>,
    _domain: PhantomData<D>,
}

impl<F: Field, S: Spec<F, T, RATE>, D: Domain<F, RATE>, const T: usize, const RATE: usize>
    fmt::Debug for Hash<F, S, D, T, RATE>
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Hash")
            .field("width", &T)
            .field("rate", &RATE)
            .field("R_F", &S::full_rounds())
            .field("R_P", &S::partial_rounds())
            .field("domain", &D::name())
            .finish()
    }
}

impl<F: Field, S: Spec<F, T, RATE>, D: Domain<F, RATE>, const T: usize, const RATE: usize>
    Hash<F, S, D, T, RATE>
{
    /// Initializes a new hasher.
    pub fn init() -> Self {
        Hash {
            sponge: Sponge::new(D::initial_capacity_element()),
            _domain: PhantomData,
        }
    }
}

impl<F: PrimeField, S: Spec<F, T, RATE>, const T: usize, const RATE: usize, const L: usize>
    Hash<F, S, ConstantLength<L>, T, RATE>
{
    pub fn hash(mut self, message: [F; L]) -> F {
        let padding = <ConstantLength<L> as Domain<F, RATE>>::padding();
        for value in message.iter().chain(padding.iter()) {
            self.sponge.absorb(*value);
        }
        self.sponge.finish_absorbing().squeeze()
    }
}

#[inline]
pub fn poseidon<const L: usize, S: Spec<Fp, POSEIDON_WIDTH, POSEIDON_RATE>>(
    message: Vec<Fp>,
) -> Result<Vec<Vec<Fp>>, Box<dyn std::error::Error>> {
    let mut hash_inputs = message;

    let mut one_iter = false;
    // do the Tree dance baby
    while hash_inputs.len() > 1 || !one_iter {
        let hashes: Vec<Fp> = hash_inputs
            .chunks(L)
            .map(|block| {
                let mut block = block.to_vec();
                let remainder = block.len() % L;

                if remainder != 0 {
                    block.extend(vec![Fp::ZERO; L - remainder].iter());
                }

                let message = block.try_into().unwrap();
                let hash = Hash::<
                    _,
                    S,
                    ConstantLength<L>,
                    { POSEIDON_WIDTH }, // width of 2 according to ezkl implementaiton
                    { POSEIDON_RATE },  // rate of 1 according to ezkl implementaiton
                >::init()
                .hash(message);
                hash
            })
            .collect();
        one_iter = true;
        hash_inputs = hashes;
    }

    Ok(vec![hash_inputs])
}
